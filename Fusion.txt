Fusion

La procédure fusion se charge d'appeler deux fonctions qui diffèrent selon le mode de fusion ou la direction.

	Commençons par une fusion en mode classique. Il s'agit de décomposer une fusion en deux étapes, répétées pour chaque colonne. Prenons l'exemple de fusion_classique_bas(unsigned int *nombreZeros, int *score, BOOL doitJouer). 
Premièrement, on se concentre sur la recherche de tuiles compatibles et le calcul de la nouvelle valeur. Pour y parvenir, on se crée plusieurs indices que l'on fait varier. Ainsi, tant qu'on tombe sur des cases neutres en montant dans la colonne, on continue de monter. Dès qu'une tuile non nulle se présente, on marque son indice de ligne puis on cherche la suivante non nulle et de même valeur, à condition que les deux ne soient séparées que par des zéros. Une fois toutes ces conditions réunies, on incrémente la valeur de la tuile de référence et on neutralise son homologue située au-dessus.
La seconde étape consiste à décaler les valeurs non-nulles le plus bas possible dans le plateau, puis à réduire à zéro les valeurs de toutes les tuiles restantes plus haut.
	Il est à noter que cette fonction se charge de modifier, en sus des tuiles elles-mêmes, le score et le nombre de cases vides, le tout grâce à de l'adressage indirect, mais uniquement lorsque l'on doit réellement jouer. La distinciton se fait lors de l'appel à la fonction, par le booléen doitJouer. Si celui-ci vaut "faux", le plateau ne sera pas réellement modifié mais simulé en vue d'aider le joueur à faire le meilleur choix.
Par ailleurs, chaque fonction de fusion renvoie un booléen. Idéalement, ceui-ci vaudrait "faux" par défaut et "vrai" si la moindre transformation altérait le plateau. Il servirait à vérifier si appliquer la fonction de fusion changerait la plateau de quelque manière que ce soit. A terme, cette condition serait utile dans d'autres fonctions, notamment le main pour générer une nouvelle tuile uniquement quand il le faut.
